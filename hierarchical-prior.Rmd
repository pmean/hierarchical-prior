----
title: "Hierarchical beta binomial"
author: "Steve Simon"
date: "Saturday, May 28, 2016"
output: html_document
---

Assume that you have two "clusters". The first is your prior data 
with 4/16 successes/failures and the second is your observed data with
18/42 successes/failures.

Now consider the same prior, but your observed data is 54/6 successes/failures.

Here is the simple beta-binomial model. The posterior mean of pi is a weighted average of the prior
mean (4/20 or 20%) and the data mean (18/60 or 30%; 54/60 or 90%).

```{r run_simple_jags_model}

library("rjags")

fnm <- "jags_beta_binomial.txt"
mon <- c("pi")

out <- list(description="jags output")

dat <- list(a=4, b=16, x=18, n=60)
mod <- jags.model(fnm, data=dat, quiet=TRUE)
out$bb1 <- 
  coda.samples(mod, variable.names=mon, n.iter=1000, by=1000, progress.bar=NULL)
summary(out$bb1)
plot(out$bb1)

dat <- list(a=4, b=16, x=54, n=60)
mod <- jags.model(fnm, data=dat, quiet=TRUE)
out$bb2 <-
  coda.samples(mod, variable.names=mon, n.iter=1000, by=1000, progress.bar=NULL)
summary(out$bb2)
plot(out$bb2)

```

You can use a hierarchical model to downweight the prior mean when the data disagrees
strongly with the prior. Here's a simple approach, though it does not work so well.


Start by assuming that both clusters (the prior and the data) are drawn from a distribution
that is beta(alpha,beta) and alpha and beta are hyperpriors distributed exponentially.

```{r run_gamma_gamma_hyperprior_model}

run_bayes <- function(x0, n0, x, n, model_name, output_name) {
  fnm <- paste("jags", model_name, "hyper.txt", sep="_")
  dat <- list(x0=x0, n0=n0, x=x, n=n)
  mon <- c("pi0", "pi1", "hyper_a", "hyper_b", "hyper_n", "hyper_pi")
  mod <- jags.model(fnm, data=dat, quiet=TRUE, n.adapt=10000)
  out[[output_name]] <<- 
    coda.samples(mod, variable.names=mon, n.iter=10000, progress.bar=NULL)
  print(summary(out[[output_name]]))  
  plot(out[[output_name]])
}

run_bayes(4, 20, 18, 60, "gamma_gamma", "gg1")
run_bayes(4, 20, 54, 60, "gamma_gamma", "gg2")

```
Try a uniform distribution instead.


```{r run_uniform_uniform_hyperprior_model}

run_bayes(4, 20, 18, 60, "uniform_uniform", "uu1")
run_bayes(4, 20, 54, 60, "uniform_uniform", "uu2")

```

The problem with this model, according to some sources is that the two hyper
parameters are correlated so highly as to make the Gibbs sampler inefficient.

You can avoid much of this correlation by re-parameterizing.

```{r run_beta_pareto_model}

run_bayes(4, 20, 18, 60, "beta_pareto", "bp1")
run_bayes(4, 20, 54, 60, "beta_pareto", "bp2")

```

I'm still working on thse sections.

```{r, compute_everything_gamma_gamma, eval=FALSE}

calculate_gamma_gamma_prior <- function(s0, s1, n) {
  s <- seq(s0, s1, length=n)
  z <- outer(exp(-s), exp(-s))
  calculate_p <- function(s_row, s_col) {s_row/(s_row+s_col)}
  return(list(s_row=s, s_col=s, z=z, calculate_p=calculate_p))
}

calculate_likelihood <- function(prior, x0, n0, x1, n1) {
  # use the same dimensions as the prior
  likelihood <- prior
  for (i in 1:length(likelihood$s_row)) {
    for (j in 1:length(likelihood$s_col)) {
      p <- prior$calculate_p(likelihood$s_row[i], likelihood$s_col[j])
      likelihood$z[i, j] <- dbinom(x0, n0, p)*dbinom(x1, n1, p)
    }
  }
  return(likelihood)
}

calculate_posterior <- function(prior, likelihood) {
  # use the same dimensions as the prior
  posterior <- prior
  posterior$z <- prior$z * likelihood$z
  posterior$z <- posterior$z / sum(posterior$z)
  return(posterior)
}

gamma_gamma_prior <- calculate_gamma_gamma_prior(0.001, 4, 400)

partial_likelihood <- calculate_likelihood(gamma_gamma_prior, 4, 20, 0, 0)

nice_likelihood <- calculate_likelihood(gamma_gamma_prior, 4, 20, 18, 60)

nasty_likelihood <- calculate_likelihood(gamma_gamma_prior, 4, 20, 54, 60)

partial_posterior <- calculate_posterior(gamma_gamma_prior, partial_likelihood)

nice_posterior <- calculate_posterior(gamma_gamma_prior, nice_likelihood)

nasty_posterior <- calculate_posterior(gamma_gamma_prior, nasty_likelihood)

```

Plot everything.

```{r plot_everything_gamma_gamma, fig.width=5, fig.height=5, eval=FALSE}

draw_surface <- function(x) {
  thin_row <- seq(1, length(x$s_row), by=10)
  thin_col <- seq(1, length(x$s_col), by=10)
  thin_z <- x$z
  thin_z <- thin_z[thin_row, ]
  thin_z <- thin_z[, thin_col]
  persp(x$s_row[thin_row], x$s_col[thin_col], thin_z, theta=40, phi=20)
}

draw_contour <- function(x) {
  contour(x$s_row, x$s_col, x$z)
}

draw_surface(gamma_gamma_prior)
draw_contour(gamma_gamma_prior)

draw_surface(nice_likelihood)
draw_contour(nice_likelihood)

draw_surface(nasty_likelihood)
draw_contour(nasty_likelihood)

draw_surface(partial_likelihood)
draw_contour(partial_likelihood)

draw_surface(nice_posterior)
draw_contour(nice_posterior)

draw_surface(nasty_posterior)
draw_contour(nasty_posterior)

draw_surface(partial_posterior)
draw_contour(partial_posterior)
```

```{r, compute_everything_beta_gamma, eval=FALSE}

calculate_beta_gamma_prior <- function(s0, s1, n) {
  s_beta <- seq(1/n, 1-(1/n), length=n)
  s_gamma <- seq(s0, s1, length=n)
  z <- outer(dbeta(s_beta, 1, 1), dgamma(s_gamma, shape=2, scale=1))
  calculate_p <- function(s_row, s_col) {s_row}
  return(list(s_row=s_beta, s_col=s_gamma, z=z, calculate_p=calculate_p))
}

beta_gamma_prior <- calculate_beta_gamma_prior(0.001, 8, 401)

partial_likelihood <- calculate_likelihood(beta_gamma_prior, 4, 20, 0, 0)

nice_likelihood <- calculate_likelihood(beta_gamma_prior, 4, 20, 18, 60)

nasty_likelihood <- calculate_likelihood(beta_gamma_prior, 4, 20, 54, 60)

partial_posterior <- calculate_posterior(beta_gamma_prior, partial_likelihood)

nice_posterior <- calculate_posterior(beta_gamma_prior, nice_likelihood)

nasty_posterior <- calculate_posterior(beta_gamma_prior, nasty_likelihood)

```

```{r plot_everything_beta_gamma, fig.width=5, fig.height=5, eval=FALSE}

draw_surface(beta_gamma_prior)
draw_contour(beta_gamma_prior)

draw_surface(nice_likelihood)
draw_contour(nice_likelihood)

draw_surface(nasty_likelihood)
draw_contour(nasty_likelihood)

draw_surface(partial_likelihood)
draw_contour(partial_likelihood)

draw_surface(nice_posterior)
draw_contour(nice_posterior)

draw_surface(nasty_posterior)
draw_contour(nasty_posterior)

draw_surface(partial_posterior)
draw_contour(partial_posterior)
```

```{r save_everything}
save.image("hierarchical-prior.RData")
```